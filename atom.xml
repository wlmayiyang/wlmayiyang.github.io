<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>mayiyang</title>
  
  <subtitle>keep solving</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wlmayiyang.github.io/"/>
  <updated>2020-12-27T04:35:39.610Z</updated>
  <id>http://wlmayiyang.github.io/</id>
  
  <author>
    <name>mayiyang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>codeforces</title>
    <link href="http://wlmayiyang.github.io/2019/12/07/codeforces/"/>
    <id>http://wlmayiyang.github.io/2019/12/07/codeforces/</id>
    <published>2019-12-07T13:13:59.000Z</published>
    <updated>2020-12-27T04:35:39.610Z</updated>
    
    <content type="html"><![CDATA[<h1 id="codeforces260C"><a href="#codeforces260C" class="headerlink" title="codeforces260C"></a><a href="http://codeforces.com/problemset/problem/260/C" target="_blank" rel="noopener">codeforces260C</a></h1><h2 id="description"><a href="#description" class="headerlink" title="description"></a><strong>description</strong></h2><blockquote><p>有n个箱子，每个箱子里都有一定数量的球。<br>现在取出某个箱子里的所有球，从后面一个位置开始，依次在后面的箱子里放入一个球，放完为止。若到第n个还没放完，回到第一个继续放。<br>已知放完后所有箱子里球的个数和结束位置，求初始状态。<br><strong>data limit</strong> 2&lt;=n&lt;=1e5,1&lt;=x&lt;=n,0&lt;=a[i]&lt;=109, a[x]!=0<br><strong>time limit</strong> 1s</p></blockquote><h2 id="solution"><a href="#solution" class="headerlink" title="solution"></a><strong>solution</strong></h2><blockquote><p>暴力算法就是从x向前扫，当访问数字为zero时停止。<br>由此，想到先取最小值，并全体减去最小值，相当于进行min×n次<br>最小值位置为开始位置(<strong><em>注意要选择从x开始第一个扫到的点</em></strong>)，向前扫即可。</p></blockquote><h2 id="code"><a href="#code" class="headerlink" title="code"></a><strong>code</strong></h2><pre><code class="lang-cpp">    for (int i=0;i&lt;n;++i)    {        a[i]-=MIN;    }    int pos=-1;    for (int i=x;;--i)    {        if (i==-1) i+=n;        if (a[i]==0)        {            pos=i;            break;        }     }    a[pos]=MIN*n;    for (int i=x;;--i)    {        if (i==-1) i+=n;        if (i==pos) break;        --a[i],++a[pos];    }</code></pre><hr><h1 id="codeforces260D"><a href="#codeforces260D" class="headerlink" title="codeforces260D"></a><a href="http://codeforces.com/problemset/problem/260/D" target="_blank" rel="noopener">codeforces260D</a></h1><h2 id="description-1"><a href="#description-1" class="headerlink" title="description"></a><strong>description</strong></h2><blockquote><p>有一颗结点为黑白两色的树，每条边都有权值且连接颜色不同的两个点，每个点的权值等于连接该点的边的权值总和<br>现在给出n个点的颜色和权值，求边的连接情况<br><strong>data limit</strong> 2&lt;=n&lt;=1e5<br><strong>time limit</strong> 1s</p></blockquote><h2 id="solution-1"><a href="#solution-1" class="headerlink" title="solution"></a><strong>solution</strong></h2><blockquote><p>黑点权值总和==白点权值总和<br>对于一个点u，边权 &lt; u的点权；因此两个点u,v边权为点权较小者。<br>v[0]保存白点，v[1]保存黑点。</p></blockquote><h2 id="code-1"><a href="#code-1" class="headerlink" title="code"></a><strong>code</strong></h2><pre><code class="lang-cpp">    int black=0,white=0;    for (;;)    {        if (black&gt;=v[1].size()) break;        if (white&gt;=v[0].size()) break;        ll val=min(v[1][black].sum,v[0][white].sum);        printf(&quot;%d %d %lld\n&quot;,v[1][black].id,v[0][white].id,val);        v[1][black].sum-=val,v[0][white].sum-=val;        if (white==v[0].size()-1) ++black;        else if (black==v[1].size()-1) ++white;        else if (v[0][white].sum==0) ++white;        else ++black;    }</code></pre><hr><h1 id="codeforces260E"><a href="#codeforces260E" class="headerlink" title="codeforces260E"></a><a href="http://codeforces.com/problemset/problem/260/E" target="_blank" rel="noopener">codeforces260E</a></h1><h2 id="description-2"><a href="#description-2" class="headerlink" title="description"></a><strong>description</strong></h2><p>给定平面上n个点和9个数，求两条平行于x轴的直线和两条平行于y轴的直线，使得被直线分成的9个区域中，点的数量和给定的9个数对应</p><h2 id="solution-2"><a href="#solution-2" class="headerlink" title="solution"></a><strong>solution</strong></h2><blockquote><p>先把点<strong>行优先</strong>排序。<br>next_permutation枚举9个数在9个区域的排列，check过程如下：<br>1.先算出4条线坐标；<br>2.用<strong>线段树</strong>维护<strong>纵坐标</strong>（维护<strong>l-r所有点</strong>的纵坐标），每次check时在一定区间内<strong>二分</strong>，统计个数</p></blockquote><h2 id="code-2"><a href="#code-2" class="headerlink" title="code"></a><strong>code</strong></h2><pre><code class="lang-cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=100005;int n,num[10],x[2],y[2];struct node{    int x,y;}a[N],b[N];vector &lt;int&gt; seg[N&lt;&lt;2];bool cmp(node a,node b){    if (a.x==b.x) return a.y&lt;b.y;    return a.x&lt;b.x;}bool cnp(node a,node b){    if (a.y==b.y) return a.x&lt;b.x;    return a.y&lt;b.y;}void build(int x,int l,int r){    for (int i=l;i&lt;=r;++i)    {        seg[x].push_back(a[i].y);    }//维护l--r所有点的纵坐标    sort(seg[x].begin(),seg[x].end());    if (l==r)    {        return;    }    int m=(l+r)&gt;&gt;1;    build(x+x,l,m);    build(x+x+1,m+1,r);}int query(int x,int l,int r,int L,int R,int limit){    if (L&lt;=l&amp;&amp;r&lt;=R)    {        return upper_bound(seg[x].begin(),seg[x].end(),limit)-seg[x].begin();    }    int m=(l+r)&gt;&gt;1,ans=0;    if (L&lt;=m) ans+=query(x+x,l,m,L,R,limit);    if (R&gt;m) ans+=query(x+x+1,m+1,r,L,R,limit);    return ans;}void init(){    scanf(&quot;%d&quot;,&amp;n);    for (int i=1;i&lt;=n;++i)    {        scanf(&quot;%d%d&quot;,&amp;a[i].x,&amp;a[i].y);        b[i]=a[i];    }    sort(a+1,a+n+1,cmp);    sort(b+1,b+n+1,cnp);    for (int i=1;i&lt;=9;++i)    {        scanf(&quot;%d&quot;,&amp;num[i]);    }    build(1,1,n);    sort(num+1,num+10);}void check(){    int p1=num[1]+num[2]+num[3];    int p2=num[1]+num[2]+num[3]+num[4]+num[5]+num[6];    int q1=num[1]+num[4]+num[7];    int q2=num[1]+num[2]+num[4]+num[5]+num[7]+num[8];    if (a[p1].x==a[p1+1].x) return;    x[0]=a[p1].x;    if (a[p2].x==a[p2+1].x) return;    x[1]=a[p2].x;    if (b[q1].y==b[q1+1].y) return;    y[0]=b[q1].y;    if (b[q2].y==b[q2+1].y) return;    y[1]=b[q2].y;    if (query(1,1,n,1,p1,y[0])!=num[1]) return;    if (query(1,1,n,1,p1,y[1])!=num[1]+num[2]) return;    if (query(1,1,n,1,p2,y[0])!=num[1]+num[4]) return;    if (query(1,1,n,1,p2,y[1])!=num[1]+num[2]+num[4]+num[5]) return;    printf(&quot;%.10lf %.10lf\n%.10lf %.10lf\n&quot;,x[0]+0.5,x[1]+0.5,y[0]+0.5,y[1]+0.5);    exit(0);}void solve(){    do    {        check();    }    while (next_permutation(num+1,num+10));    printf(&quot;-1\n&quot;);    return;}</code></pre><hr><h1 id="codeforces585C"><a href="#codeforces585C" class="headerlink" title="codeforces585C"></a><a href="http://codeforces.com/problemset/problem/585/C" target="_blank" rel="noopener">codeforces585C</a></h1><h2 id="description-3"><a href="#description-3" class="headerlink" title="description"></a><strong>description</strong></h2><blockquote><p>$a=1,b=1$，构造一个AB字符串，遇到Ａ执行$b=a+b$，遇到Ｂ执行$a=a+b$</p><p>要求最终$a=x ,b=y$</p><p><strong>data limit</strong> $x,y&lt;=1e18$</p></blockquote><h2 id="solution-3"><a href="#solution-3" class="headerlink" title="solution"></a><strong>solution</strong></h2><blockquote><p>从终态逆推，容易发现是在执行辗转相减，运用辗转相除求gcd的过程加速辗转相减</p><p>注意$gcd(x,y)!=1$是无解</p></blockquote><hr><h1 id="codeforces585E"><a href="#codeforces585E" class="headerlink" title="codeforces585E"></a><a href="http://codeforces.com/problemset/problem/585/E" target="_blank" rel="noopener">codeforces585E</a></h1><h2 id="description-4"><a href="#description-4" class="headerlink" title="description"></a><strong>description</strong></h2><blockquote><p>有n个数，可以从中任意选取一个x，然后可以从剩下的数中选取任意个构成一个集合S，使集合S中所有数的$gcd(S)&gt;1$，且$gcd(gcd(S),x)=1$，求方案数。</p></blockquote><h2 id="solution-4"><a href="#solution-4" class="headerlink" title="solution"></a><strong>solution</strong></h2><blockquote><p>先用$tmp[i]$表示$i$的倍数有几个，</p><p>对于每个质数$x$，选出$x$的倍数(共$tmp[x]$个)，会对答案贡献$(n-tmp[x])*(2^{tmp[x]}-1)$</p><p>此时考虑$prime1\ast prime2$，在枚举$prime1,prime2$时都计算到，需要$ans-=(n-tmp[x])\ast (2^{tmp[x]}-1)$；</p><p>类似的，三个质数乘积$p\ast q\ast r$，在$p,q,r$分别加一次，$p\ast q$，$p\ast r$，$q\ast r$分别减一次，因此还要加一遍</p><p>若一个质因子$p$出现两遍，要么在$p$中算过，要么$gcd!=1$，因此对答案没有贡献</p><p>容易发现，容斥系数恰好为$-mu[x]$</p><p>暴枚$i$，$ans+=(-mu[i])\ast(2^{tmp[i]}-1)\ast(n-tmp[i])$</p></blockquote><h1 id="codeforces1013B"><a href="#codeforces1013B" class="headerlink" title="codeforces1013B"></a><a href="http://codeforces.com/problemset/problem/1013/B" target="_blank" rel="noopener">codeforces1013B</a></h1><h2 id="description-5"><a href="#description-5" class="headerlink" title="description"></a><strong>description</strong></h2><h2 id="solution-5"><a href="#solution-5" class="headerlink" title="solution"></a><strong>solution</strong></h2><h1 id="codeforces1060D"><a href="#codeforces1060D" class="headerlink" title="codeforces1060D"></a><a href="http://codeforces.com/problemset/problem/1060/D" target="_blank" rel="noopener">codeforces1060D</a></h1><h2 id="description-6"><a href="#description-6" class="headerlink" title="description"></a><strong>description</strong></h2><h2 id="solution-6"><a href="#solution-6" class="headerlink" title="solution"></a><strong>solution</strong></h2><h1 id="codeforces1060E"><a href="#codeforces1060E" class="headerlink" title="codeforces1060E"></a><a href="http://codeforces.com/problemset/problem/1060/E" target="_blank" rel="noopener">codeforces1060E</a></h1><h2 id="description-7"><a href="#description-7" class="headerlink" title="description"></a><strong>description</strong></h2><h2 id="solution-7"><a href="#solution-7" class="headerlink" title="solution"></a><strong>solution</strong></h2><h1 id="codeforces1080C"><a href="#codeforces1080C" class="headerlink" title="codeforces1080C"></a><a href="http://codeforces.com/problemset/problem/1080/C" target="_blank" rel="noopener">codeforces1080C</a></h1><h2 id="description-8"><a href="#description-8" class="headerlink" title="description"></a><strong>description</strong></h2><h2 id="solution-8"><a href="#solution-8" class="headerlink" title="solution"></a><strong>solution</strong></h2><h1 id="codeforces1083B"><a href="#codeforces1083B" class="headerlink" title="codeforces1083B"></a><a href="http://codeforces.com/problemset/problem/1083/B" target="_blank" rel="noopener">codeforces1083B</a></h1><h2 id="description-9"><a href="#description-9" class="headerlink" title="description"></a><strong>description</strong></h2><h2 id="solution-9"><a href="#solution-9" class="headerlink" title="solution"></a><strong>solution</strong></h2><h1 id="codeforces1182E"><a href="#codeforces1182E" class="headerlink" title="codeforces1182E"></a><a href="http://codeforces.com/problemset/problem/1182/E" target="_blank" rel="noopener">codeforces1182E</a></h1><h2 id="description-10"><a href="#description-10" class="headerlink" title="description"></a><strong>description</strong></h2><h2 id="solution-10"><a href="#solution-10" class="headerlink" title="solution"></a><strong>solution</strong></h2><h1 id="codeforces1243D"><a href="#codeforces1243D" class="headerlink" title="codeforces1243D"></a><a href="http://codeforces.com/problemset/problem/1243/D" target="_blank" rel="noopener">codeforces1243D</a></h1><h2 id="description-11"><a href="#description-11" class="headerlink" title="description"></a><strong>description</strong></h2><blockquote><p>$n$个点的完全无向图，$m$条边边权为1，其余边权为0，求最小生成树</p><p>$n,m&lt;=1e5$</p></blockquote><h2 id="solution-11"><a href="#solution-11" class="headerlink" title="solution"></a><strong>solution</strong></h2><blockquote><p>容易得到答案为补图的联通块个数，运用链表+bfs解决</p><p>每次选取一个未分配的点，从这个点 bfs。链表中存储没访问的点</p><p>假设当前点是 u ，如果原图上有边 u -&gt; v ，就把点 v 标记（$cover[v]=1$）。从链表头遍历，对于$cover[v]=0$的点，塞入队列，并从链表中删除。</p><p>注意还要把标记取消!!!</p><p>因为每个点和每条边都只会走一次，复杂度是$O(n+m)$ 。</p></blockquote><hr><h1 id="codeforces1247E"><a href="#codeforces1247E" class="headerlink" title="codeforces1247E"></a><a href="http://codeforces.com/problemset/problem/1247/E" target="_blank" rel="noopener">codeforces1247E</a></h1><h2 id="description-12"><a href="#description-12" class="headerlink" title="description"></a><strong>description</strong></h2><blockquote><p>一个n*m的矩阵，有个别位置会有石头，石头受到撞击会沿着方向撞到墙为止（每个小球会占一个格子）。你从左上角出发，只能向右或者向下走，问你走到右下角的方案数。</p></blockquote><h2 id="solution-12"><a href="#solution-12" class="headerlink" title="solution"></a><strong>solution</strong></h2><blockquote><p>先统计每个位置右边，下边有几个石头，存在$row$与$col$中</p><p>考虑动态规划，$dp[i][j][0]$表示从$(i,j)$出发向右移动至终点的方案数，$dp[i][j][1]$表示从$(i,j)$出发向下移动至终点的方案数。考虑向右移动时，最远可以移到$(i,m-row[i][j+1])$，<script type="math/tex">dp[i][j][0]=\sum_{p=j+1}^{m-row[i][j+1]}dp[i][p][1]</script></p><p>同理 <script type="math/tex">dp[i][j][1]=\sum_{p=i+1}^{n-col[i+1][j]}dp[p][j][0]</script></p><p>运用前缀和优化$dp$即可</p><p>时间复杂度$O(n^2)$</p></blockquote><hr><h1 id="codeforces1284D"><a href="#codeforces1284D" class="headerlink" title="codeforces1284D"></a><a href="http://codeforces.com/problemset/problem/1284/D" target="_blank" rel="noopener">codeforces1284D</a></h1><h2 id="description-13"><a href="#description-13" class="headerlink" title="description"></a><strong>description</strong></h2><blockquote><p>线段集合$A,B$分别含有$n$条线段，若存在$A_i$与$A_j$相交，但$B_i$与$B_j$不相交，输出no</p></blockquote><h2 id="solution-13"><a href="#solution-13" class="headerlink" title="solution"></a><strong>solution</strong></h2><blockquote><p>与<a href="http://codeforces.com/problemset/problem/1106/E" target="_blank" rel="noopener">cf1106E</a>预处理做法相似，类似于扫描线</p><p>对于每一段线段：</p><p>1.在$tim=sa_i$处插入$[sb_i,eb_i]$，并加入$insert$标记（即$typ=1$）</p><p>2.在$tim=ea_i+1$处删除$[sb_i,eb_i]$，并加入$remove$标记（即$typ=-1$）</p><p>把上述$2*n$个事件按$tim$排序</p><p><strong>attention：当$tim$相等时，先删除区间，再加入新的区间！！！</strong></p><p>这样的话，对于每个时间点$tim$，能够维护哪些$A$线段会覆盖$tim$。显然，这些$A$线段两两相交，因此，对应的$B$线段也必须两两相交。（<strong>核心</strong>）</p><p>区间$[a,b]$,$[c,d]$不相交，当且仅当$b&lt;c$或$d&lt;a$。</p><p>若$ea_i&lt;\max(sb)$或$sa_i&gt;\min(eb)$，则新加入的线段不满足两两相交</p><p>上述信息只需要维护两个$multiset$，一个维护插入的区间左端点$sb$，另一个维护插入的区间的右端点$eb$</p><p>上述过程仅仅考虑$A$线段相交,$B$线段不相交，还需要交换$A$,$B$后再来一次</p></blockquote><hr><h1 id="codeforces1284E"><a href="#codeforces1284E" class="headerlink" title="codeforces1284E"></a><a href="http://codeforces.com/problemset/problem/1284/E" target="_blank" rel="noopener">codeforces1284E</a></h1><h2 id="description-14"><a href="#description-14" class="headerlink" title="description"></a><strong>description</strong></h2><blockquote><p>平面上$n$个点，选一个点与一个四边形的组合，使得该点在四边形内的数量有多少个？</p></blockquote><h2 id="solution-14"><a href="#solution-14" class="headerlink" title="solution"></a><strong>solution</strong></h2><blockquote><p>考虑这五个点的凸包：</p><p>1.凸包有五个点，情况数记为$n_5$，此时不存在这样的组合</p><p>2.凸包有四个点，情况数记为$n_4$，此时剩下的一个点在凸包内，$ans+=n_4$</p><p>3.凸包有三个点，情况数记为$n_3$，此时剩下的两个点在与另外的四个点满足，$ans+=2\ast n_3$</p><p>$\therefore ans=2\ast n_3+n_4$</p><p>而$\because n_3+n_4+n_5=C_{n}^{5}$</p><p>$\therefore ans=5\ast(n_3+n_4+n_5)-(3n_3+4n_4+5n_5)=5C_{n}^{5}-(3n_3+4n_4+5n_5)$</p><p>$3n_3+4n_4+5n_5$即为五点凸包边数之和</p><p>然后考虑枚举$n^2$条边，统计有多少个五点凸包经过该边</p><p>不妨</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;codeforces260C&quot;&gt;&lt;a href=&quot;#codeforces260C&quot; class=&quot;headerlink&quot; title=&quot;codeforces260C&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://codeforces.com/problemset/pr
      
    
    </summary>
    
    
      <category term="题目" scheme="http://wlmayiyang.github.io/categories/%E9%A2%98%E7%9B%AE/"/>
    
      <category term="cf" scheme="http://wlmayiyang.github.io/categories/%E9%A2%98%E7%9B%AE/cf/"/>
    
    
      <category term="problems" scheme="http://wlmayiyang.github.io/tags/problems/"/>
    
      <category term="cf" scheme="http://wlmayiyang.github.io/tags/cf/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://wlmayiyang.github.io/2019/12/07/hello-world/"/>
    <id>http://wlmayiyang.github.io/2019/12/07/hello-world/</id>
    <published>2019-12-07T13:04:18.490Z</published>
    <updated>2019-12-07T13:04:18.490Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="lang-bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="lang-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="lang-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="lang-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
